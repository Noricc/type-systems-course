#+TITLE: Simply typed lambda calculus
#+AUTHOR: Noric Couderc
#+LATEX_CLASS: beamer
#+OPTIONS: toc:nil
#+BEAMER_THEME: Madrid
#+LATEX_HEADER: \usepackage{libertine}
#+LATEX_HEADER: \usepackage{bussproofs}
#+LATEX_HEADER: \usepackage[dvipsnames]{xcolor}
#+LATEX_HEADER: \newcommand{\type}[1]{\textcolor{purple}{#1}}
#+LATEX_HEADER: \newcommand{\term}[1]{\textcolor{blue}{#1}}


* Untyped Lambda calculus

** Syntax
  - $x$: Variables
  - $\lambda x . t$: Functions
  - $t~x$: Function application

** Evaluation

  \begin{prooftree}
  \AxiomC{$t_1 \rightarrow t_1'$}
  \RightLabel{E-APP1}
  \UnaryInfC{$t_1 t_2 \rightarrow t_1' t_2$}
  \end{prooftree}

  \begin{prooftree}
  \AxiomC{$t_2 \rightarrow t_2'$}
  \RightLabel{E-APP2}
  \UnaryInfC{$t_1 t_2 \rightarrow t_1 t_2'$}
  \end{prooftree}

  \begin{prooftree}
  \RightLabel{E-AppAbs}
  \AxiomC{$(\lambda x . t_{12}) v_2 \rightarrow [x \mapsto v_2]t_{12}$}
  \end{prooftree}


* Typing relation

** Problem
   The untyped lambda calculus can get stuck: $x$ is a term.

** Solution
  - We want to type our terms. We create a typing relation, notated with a ternary operator: $\_ \vdash \_ : \_$
  - $\Gamma \vdash t : \type{T}$ means the term $t$ is of type $\type{T}$ in the context $\Gamma$

* Typed Lambda Calculus
** Syntax
   - $x$ : variables
   - $\lambda x : \type{T} . t$ : functions (with input type!)
   - $t~t$ : function application

** Types
   - $\type{T \rightarrow T}$ : Functions

** Contexts
   - $\varnothing$: The empty context
   - $\Gamma, x : \type{T}$: adding $(x, \type{T})$ to the context $\Gamma$.

* Typing rules (T-VAR)

  Typing rule for variables

  \huge
  \begin{prooftree}
  \AxiomC{$x : \type{T} \in \Gamma$}
  \RightLabel{T-VAR}
  \UnaryInfC{$\Gamma \vdash x : \type{T}$}
  \end{prooftree}

* Typing rules (T-ABS)

  Typing rule for abstraction (creating functions)

  \huge
  \begin{prooftree}
  \AxiomC{$\Gamma, x : \type{T_1} \vdash t_2 : \type{T_2}$}
  \RightLabel{T-ABS}
  \UnaryInfC{$\Gamma \vdash \lambda x : \type{T_1} . t_2 : \type{T_1 \rightarrow T_2}$}
  \end{prooftree}

* Typing rules (T-APP)

  Typing rule for applying functions

  \huge
  \begin{prooftree}
  \AxiomC{$\Gamma \vdash t1 : \type{T_{11} \rightarrow T_{12}}$}
  \AxiomC{$\Gamma \vdash t_2 : \type{T_{11}}$}
  \RightLabel{T-APP}
  \BinaryInfC{$\Gamma \vdash t_1~t_2 : \type{T_{12}}$}
  \end{prooftree}

* Pure Lambda Calculus: Typing Rules

** Typing rule for variables

  \begin{prooftree}
  \AxiomC{$x : \type{T} \in \Gamma$}
  \RightLabel{T-VAR}
  \UnaryInfC{$\Gamma \vdash x : \type{T}$}
  \end{prooftree}

** Typing rule for creating functions

  \begin{prooftree}
  \AxiomC{$\Gamma, x : \type{T_1} \vdash t_2 : \type{T_2}$}
  \RightLabel{T-ABS}
  \UnaryInfC{$\Gamma \vdash \lambda x : \type{T_1} . t_2 : \type{T_1 \rightarrow T_2}$}
  \end{prooftree}

** Typing rule for applying functions

  \begin{prooftree}
  \AxiomC{$\Gamma \vdash t1 : \type{T_{11} \rightarrow T_{12}}$}
  \AxiomC{$\Gamma \vdash t_2 : \type{T_{11}}$}
  \RightLabel{T-APP}
  \BinaryInfC{$\Gamma \vdash t_1~t_2 : \type{T_{12}}$}
  \end{prooftree}

* Making it more interesting

  - The pure lambda calculus does not have any well-typed expressions: *Why?*
  - We can add one type: Booleans

** Typing rules for Booleans

  \begin{equation*}
        \text{true}: \type{\text{Bool}}
  \end{equation*}

  \begin{equation*}
        \text{false}: \type{\text{Bool}}
  \end{equation*}

  \begin{prooftree}
  \AxiomC{$t_1 : \type{\text{Bool}}$}
  \AxiomC{$t_2 : \type{T}$}
  \AxiomC{$t_3 : \type{T}$}
  \TrinaryInfC{$\text{if}~t_1~\text{then}~t_2~\text{else}~t_3~:~\type{T}$}
  \end{prooftree}

* Properties of typing
** Inversion
   If a term is well typed it's sub-terms are also well typed.

** Uniqueness
   Each term has only one type

** Canonical forms
   1. If $v : \type{\text{Bool}}$, then $v$ is either $true$ or $false$
   2. If $v : \type{T_1 \rightarrow T_2}$, then $v = \lambda x : \type{T_1} . t_2$
** Permutation
   Taking a permutation of the type context doesn't change the typing of the program (order doesn't matter?)

* Making type systems useful
  \centering
  \huge{Safety = Progress + Preservation}
* Preservation
  Evaluation doesn't change types

  More formally:

  If:
  - $\Gamma, x:\type{S} \vdash t:\type{T}$
  - $\Gamma \vdash s : \type{S}$


  Then:
  - $\Gamma \vdash [x \rightarrow s] t$

* Progress
  If a term is well typed, it's either a value or we can evaluate it
  (Well-typed programs don't get stuck)

  More formally:
  If $t$ is a closed, well-typed term of type $\type{T}$,
  then either $t$ is a value, or there is some
  $t'$ with $t \rightarrow t'$.

** Proof intuition
   - Suppose $t$ is of type $T$
   - $t : \type{\type{\text{Bool}}}$
     - $t = \text{true}$ , done
     - $t = \text{false}$ , done
     - $t = \text{if}~t_1~\text{then \dots else \dots}$ : use induction hypothesis to evaluate $t_1$
   - $t : \type{T_1 \rightarrow T_2}$ , done (functions are values)
   - $t = t_1~t_2$, either:
     - We can evaluate $t_1$
     - We can evaluate $t_2$

* Curry-Howard Correspondence

  | Logic                       | Programming languages                |
  |-----------------------------+--------------------------------------|
  | propositions                | types                                |
  | proposition $P \supset Q$   | type $P \rightarrow Q$               |
  | proposition $P \land Q$     | type $P \times Q$ (tuples)           |
  | proof of proposition $P$    | term $t$ of type $P$                 |
  | proposition $P$ is provable | type $P$ is inhabited (by some term) |

  Why do we care?

* Erasure

  You don't need types to evaluate (their purpose is to check the program is correct)

* What did we learn?

  - You can add types to lambda calculus with:
    - Progress: A well-typed program won't get stuck
    - Preservation: You can do substitution while keeping the types
  - Programs and proofs are the same
    - Which means lambda-calculus can actually be useful
