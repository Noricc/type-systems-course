#+TITLE: Type Systems Course: Simply typed lambda calculus
#+AUTHOR: Noric Couderc
#+LATEX_CLASS: beamer
#+OPTIONS: toc:nil
#+BEAMER_THEME: Madrid
#+LATEX_HEADER: \usepackage{libertine}
#+LATEX_HEADER: \usepackage{bussproofs}

* Untyped Lambda calculus

  - $x$: Variables
  - $\lambda x . t$: Functions
  - $t~x$: Function application

* Typed Lambda Calculus

** Syntax
   - $x$ : variables
   - $\lambda x : T . t$ : functions (with input type!)
   - $t~t$ : function application

** Types
   - $T \rightarrow T$ : Functions

** Contexts
   - $\varnothing$: The empty context
   - $\Gamma, x : T$: adding $(x, T)$ to the context $\Gamma$.

* Typing relation

  We want to type our terms. We create a typing relation, notated with a ternary operator: $\_ \vdash \_ : \_$

  $\Gamma \vdash t : T$ means the term $t$ is of type $T$ in the context $\Gamma$

* Typing rules (T-VAR)

  Typing rule for variables

  \begin{prooftree}
  \AxiomC{$x : T \in \Gamma$}
  \RightLabel{T-VAR}
  \UnaryInfC{$\Gamma \vdash x : T$}
  \end{prooftree}

* Typing rules (T-ABS)

  Typing rule for creating functions

  \begin{prooftree}
  \AxiomC{$\Gamma, x : T_1 \vdash t_2 : T_2$}
  \RightLabel{T-ABS}
  \UnaryInfC{$\Gamma \vdash \lambda x : T_1 . t_2 : T_1 \rightarrow T_2$}
  \end{prooftree}


* Typing rules (T-APP)

  Typing rule for applying functions

  \begin{prooftree}
  \AxiomC{$\Gamma \vdash t1 : T_{11} \rightarrow T_{12}$}
  \AxiomC{$\Gamma \vdash t_2 : T_{11}$}
  \RightLabel{T-APP}
  \BinaryInfC{$\Gamma \vdash t_1~t_2 : T_{12}$}
  \end{prooftree}

* Pure Lambda Calculus: Typing Rules

** Typing rule for variables

  \begin{prooftree}
  \AxiomC{$x : T \in \Gamma$}
  \RightLabel{T-VAR}
  \UnaryInfC{$\Gamma \vdash x : T$}
  \end{prooftree}

** Typing rule for creating functions

  \begin{prooftree}
  \AxiomC{$\Gamma, x : T_1 \vdash t_2 : T_2$}
  \RightLabel{T-ABS}
  \UnaryInfC{$\Gamma \vdash \lambda x : T_1 . t_2 : T_1 \rightarrow T_2$}
  \end{prooftree}

** Typing rule for applying functions

  \begin{prooftree}
  \AxiomC{$\Gamma \vdash t1 : T_{11} \rightarrow T_{12}$}
  \AxiomC{$\Gamma \vdash t_2 : T_{11}$}
  \RightLabel{T-APP}
  \BinaryInfC{$\Gamma \vdash t_1~t_2 : T_{12}$}
  \end{prooftree}

* Making it more interesting

  - The pure lambda calculus does not have any well-typed expressions: *Why?*
  - We can add one type: Booleans

** Typing rules for Booleans

  \begin{equation*}
        \text{true}: \text{Bool}
  \end{equation*}

  \begin{equation*}
        \text{false}: \text{Bool}
  \end{equation*}

  \begin{prooftree}
  \AxiomC{$t_1 : \text{Bool}$}
  \AxiomC{$t_2 : T$}
  \AxiomC{$t_3 : T$}
  \TrinaryInfC{$\text{if}~t_1~\text{then}~t_2~\text{else}~t_3~:~T$}
  \end{prooftree}

* Properties of typing

  Safety = Progress + Preservation

** Inversion
   If a term is well typed it's sub-terms are also well typed.

** Uniqueness
   Each term has only one type

** Canonical forms
   Not sure about this one

** Progress
   If a term is well typed, it's either a value or we can evaluate it
   (Well-typed programs don't get stuck)

** Permutation
   Taking a permutation of the type context doesn't change the typing of the program (order doesn't matter?)

** Preservation
   Evaluation doesn't change types

* Curry-Howard Correspondence
  **Programs and proofs are the same**

* Erasure
  You don't need types to evaluate (their purpose is to check the program is correct)
