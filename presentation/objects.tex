\documentclass[presentation,xcolor=svgnames]{beamer}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{tikz}

\usepackage{listings}
\lstset{
  basicstyle=\small\ttfamily,
  gobble=4,
}

\usetikzlibrary{arrows.meta}

\usepackage[sfdefault,book]{FiraSans} %% option 'sfdefault' activates Fira Sans as the default text font
\usepackage{FiraMono}

\renewcommand*\oldstylenums[1]{{\firaoldstyle #1}}

% \usepackage[dvipsnames]{xcolor}
\definecolor{light}{rgb}{0.5, 0.5, 0.5}
\def\light#1{{\color{light}#1}}

\author{Noric Couderc}
\date{\today}
\title{Case Study: Imperative Objects}

\begin{document}


\maketitle

\section{Intro}
\begin{frame}
  \begin{itemize}
  \item What is object oriented programming?
  \item How to implement OOP in our language?
  \end{itemize}
\end{frame}

\section{Object Oriented Programming}


\begin{frame}{Five rules of object-oriented programming}
\begin{itemize}
\item Multiple Representations
\item Encapsulation
\item Subtyping
\item Inheritance
\item Open recursion
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Multiple representations}
\begin{block}{Dynamic dispatch}
\begin{verbatim}
walks(dog)
\end{verbatim}
\begin{verbatim}
walks(cat)
\end{verbatim}
\end{block}

\begin{block}{Syntactic sugar}
\begin{verbatim}
barks(dog, cat) = dog.barks(cat)
\end{verbatim}
\end{block}
\end{frame}

\begin{frame}{Encapsulation}
  \centering
  Objects have an \textbf{inside} and an \textbf{outside}\\
  If you're \textbf{outside} you can't see \textbf{inside}
\end{frame}

\tikzset{
  classbox/.style={
    rectangle,
    draw,
    text width=1.5cm,
    text centered,
    },
}

\begin{frame}{Subtyping}
  \centering
  \begin{tikzpicture}[thick,>=Stealth]
    \node[classbox] (interface) at (0,0) {Animal};
    \node[classbox] (class1) at (-1, -2) {Cat};
    \node[classbox] (class2) at (1, -2) {Dog};

    \draw[->] (class1) -- (interface);
    \draw[->] (class2) -- (interface);
  \end{tikzpicture}
\end{frame}

\begin{frame}{Inheritance}
  \centering
  \begin{tikzpicture}[thick,>=Stealth]
    \node[classbox] (interface) at (0,0) {\textbf{Animal}\\walk};
    \node[classbox] (class1) at (-1, -2) {\textbf{Cat}\\meow\\\light{walk}};
    \node[classbox] (class2) at (1, -2) {\textbf{Dog}\\bark\\\light{walk}};

    \draw[->] (class1) -- (interface);
    \draw[->] (class2) -- (interface);
  \end{tikzpicture}
\end{frame}

\begin{frame}{Open recursion}
  \centering
  Methods of an object can call each other
\end{frame}

\section{Objects}

\begin{frame}[fragile]
  An object is just a record of functions / methods

    \begin{lstlisting}[mathescape=true]
    c = let x = ref 1 in
        {get = $\lambda$_:Unit. !x
         inc = $\lambda$_:Unit. x := succ(!x)};
    \end{lstlisting}

    \texttt{let x = .. in ..} provides encapsulation.

\end{frame}

\begin{frame}[fragile]{Constructors}
  \begin{lstlisting}
    Counter = { get : Unit -> Nat, inc : Unit -> Unit }
  \end{lstlisting}

  \begin{lstlisting}[mathescape=true]
    newCounter =
      $\lambda$_:Unit. let x = ref 1 in
        {get = $\lambda$_:Unit. !x,
         inc = $\lambda$_:Unit. x:=succ(!x)};
  \end{lstlisting}

  \begin{lstlisting}
    newCounter : Unit -> Counter
  \end{lstlisting}
\end{frame}

% \newcommand{\addedline}[1]{\tikz{\node[fill=green,inner sep=0pt]{#1}}}

\newcommand{\addedline}[1]{\colorbox{green}{#1}}

\begin{frame}[fragile]{Subtyping}
  Adding a method to a record creates a subtype
  \begin{block}{ }
  \begin{lstlisting}[mathescape=true,escapeinside={(*}{*)}]
    newResetCounter =
      $\lambda$_:Unit. let x = ref 1 in
        {get = $\lambda$_:Unit. !x,
         inc = $\lambda$_:Unit. x:=succ(!x),
         (*\addedline{reset := $\lambda$\_:Unit. x:=1}*)};
  \end{lstlisting}
  \end{block}

  \begin{lstlisting}
    ResetCounter =
    { get : Unit -> Nat,
      inc : Unit -> Unit,
      reset : Unit -> Unit}
  \end{lstlisting}

  \texttt{ResetCounter <: Counter} because of \textsc{RcdWidth}

\end{frame}

\section{Classes}

\begin{frame}{Classes}
  \begin{block}{Problems}
    \begin{itemize}
    \item We have to write the methods again!
    \item We can't use assignment for copying methods
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Classes}
  \begin{block}{Solution}
    \begin{itemize}
    \item A \textbf{class} is a \textbf{function} on \textbf{instance records}
    \item Classes are \textbf{functions}, not \textbf{types}
    \end{itemize}
  \end{block}
  \begin{lstlisting}[escapeinside={(*}{*)}]
    (*\addedline{counterRep = \{ x : Ref Nat\};}*)
  \end{lstlisting}
  \begin{lstlisting}[mathescape=true,escapeinside={(*}{*)}]
    counterClass =
      $\lambda$(*\addedline{r:CounterRep}*).
        {get = $\lambda$_:Unit !(r.x),
         inc = $\lambda$_:Unit. r.x := succ(!(r.x))};

    counterClass : CounterRep -> Counter
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Inheritance}
  Call the class on the instance record to get \texttt{super}

  % Could use colors for SELF, SUPER, and the INSTANCE RECORD
  \begin{lstlisting}[mathescape=true,escapeinside={(*}{*)}]
    resetCounterClass =
      $\lambda$r:CounterRep.
      (*\addedline{let super = counterClass r in}*)
        {get=(*\addedline{super.get}*),
         inc=(*\addedline{super.inc}*),
         (*\addedline{reset = $\lambda$\_:Unit. r.x := 1\}}*)
  \end{lstlisting}

  \begin{block}{}
  \texttt{reset} and \texttt{super.get} use the same \texttt{r.x}!
  \end{block}

\end{frame}

\section{Open Recursion}

\begin{frame}
  \centering
  \huge \textbf{A frame}
\end{frame}

\begin{frame}[fragile]{Open recursion: Fix}
  \begin{lstlisting}[mathescape=true]
    setCounterClass =
    $\lambda$r:CounterRep.
      fix
        ($\lambda$self: SetCounter.
          {get=$\lambda$_:Unit. !(r.x),
           set=$\lambda$i:Nat. r.x := i,
           inc=$\lambda$_:Unit.
               r.x := self.set (succ (self.get unit))
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Open recursion: Fix: Problems}
  \begin{block}{Problem}
    Calling \texttt{fix} creates an infinite loop!
  \end{block}
\end{frame}

\begin{frame}[fragile]{Reminder: Recursion}
  \begin{lstlisting}[mathescape=true,escapeinside={(*}{*)}]
    (*\textcolor{red}{iseven}*) =
      $\lambda$x:Nat.
        if iszero x then true
        else if iszero (pred x) then false
        else (*\textcolor{red}{iseven}*) (pred(pred x))
  \end{lstlisting}
  \begin{lstlisting}[mathescape=true,escapeinside={(*}{*)}]
    (*\textcolor{red}{iseven}*) =
      (*\addedline{fix}*)
      (*\addedline{$\lambda$ie:Nat -> Bool}*)
        $\lambda$x:Nat.
          if iszero x then true
          else if iszero (pred x) then false
          else (*\textcolor{ForestGreen}{ie}*) (pred(pred x))
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Open recursion: Fix: Thunking}
  \textbf{Thunking} is when \emph{delay} a computation by wrapping it in a function.

  \begin{block}{Example}
    $3 + 2 \rightarrow \lambda \_. (3 + 2)$
  \end{block}

  The body will be evaluated when you call the function!
\end{frame}

\begin{frame}[fragile]{Open recursion: References}
references
\end{frame}

\end{document}
