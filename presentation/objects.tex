\documentclass[presentation]{beamer}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{tikz}

\usepackage{listings}
\lstset{
  basicstyle=\small\ttfamily,
}

\usetikzlibrary{arrows.meta}

\usepackage[sfdefault,book]{FiraSans} %% option 'sfdefault' activates Fira Sans as the default text font
\usepackage{FiraMono}

\renewcommand*\oldstylenums[1]{{\firaoldstyle #1}}

\usepackage{color}
\definecolor{light}{rgb}{0.5, 0.5, 0.5}
\def\light#1{{\color{light}#1}}

\author{Noric Couderc}
\date{\today}
\title{Case Study: Imperative Objects}

\begin{document}


\maketitle

\section{Intro}
\begin{frame}
  \begin{itemize}
  \item What is object oriented programming?
  \item How to implement OOP in our language?
  \end{itemize}
\end{frame}

\section{Object Oriented Programming}


\begin{frame}{Five rules of object-oriented programming}
\begin{itemize}
\item Multiple Representations
\item Encapsulation
\item Subtyping
\item Inheritance
\item Open recursion
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Multiple representations}
\begin{block}{Dynamic dispatch}
\begin{verbatim}
walks(dog)
\end{verbatim}
\begin{verbatim}
walks(cat)
\end{verbatim}
\end{block}

\begin{block}{Syntactic sugar}
\begin{verbatim}
barks(dog, cat) = dog.barks(cat)
\end{verbatim}
\end{block}
\end{frame}

\begin{frame}{Encapsulation}
  \centering
  Objects have an \textbf{inside} and an \textbf{outside}\\
  If you're \textbf{outside} you can't see \textbf{inside}
\end{frame}

\tikzset{
  classbox/.style={
    rectangle,
    draw,
    text width=1.5cm,
    text centered,
    },
}

\begin{frame}{Subtyping}
  \centering
  \begin{tikzpicture}[thick,>=Stealth]
    \node[classbox] (interface) at (0,0) {Animal};
    \node[classbox] (class1) at (-1, -2) {Cat};
    \node[classbox] (class2) at (1, -2) {Dog};

    \draw[->] (class1) -- (interface);
    \draw[->] (class2) -- (interface);
  \end{tikzpicture}
\end{frame}

\begin{frame}{Inheritance}
  \centering
  \begin{tikzpicture}[thick,>=Stealth]
    \node[classbox] (interface) at (0,0) {\textbf{Animal}\\walk};
    \node[classbox] (class1) at (-1, -2) {\textbf{Cat}\\meow\\\light{walk}};
    \node[classbox] (class2) at (1, -2) {\textbf{Dog}\\bark\\\light{walk}};

    \draw[->] (class1) -- (interface);
    \draw[->] (class2) -- (interface);
  \end{tikzpicture}
\end{frame}

\begin{frame}{Open recursion}
  \centering
  Methods of an object can call each other
\end{frame}

\section{Objects}

\begin{frame}[fragile]
  \centering
  An object is just a record of functions

    \begin{lstlisting}[mathescape=true]
    c = let x = ref 1 in
        {get = $\lambda$_:Unit. !x
         inc = $\lambda$_:Unit. x := succ(!x)};
    \end{lstlisting}

    \texttt{let x = .. in ..} provides encapsulation.
\end{frame}

\begin{frame}[fragile]{Constructors}
  \centering
  \begin{lstlisting}[mathescape=true]
    newCounter =
      $\lambda$_:Unit. let x = ref 1 in
        {get = $\lambda$_:Unit. !x,
         inc = $\lambda$_:Unit. x:=succ(!x)};
  \end{lstlisting}

  \begin{lstlisting}
    Counter = { get : Unit -> Nat, inc : Unit -> Unit }
  \end{lstlisting}
\end{frame}

\newcommand{\addedline}[1]{\tikz{\node[fill=green]{#1}}}

\begin{frame}[fragile]{Subtyping}
  \centering
  \begin{block}{ }
  \begin{lstlisting}[mathescape=true,escapeinside={(*}{*)}]
    newResetCounter =
      $\lambda$_:Unit. let x = ref 1 in
        {get = $\lambda$_:Unit. !x,
         inc = $\lambda$_:Unit. x:=succ(!x),
         (*\addedline{reset := $\lambda$\_:Unit. x:=1}*)};
  \end{lstlisting}
  \end{block}

  \centering
  \begin{lstlisting}
    ResetCounter =
    { get : Unit -> Nat,
      inc : Unit -> Unit,
      reset : Unit -> Unit}
  \end{lstlisting}

  \centering
  \texttt{ResetCounter <: Counter} because of \textsc{RcdWidth}

\end{frame}

\section{Classes}

\begin{frame}
  \centering
  A \textbf{class} is a \textbf{function} on \textbf{instance records}

\end{frame}

\begin{frame}{Inheritance}
  \centering
  \texttt{super} is defined by calling the class on the record
\end{frame}

\begin{frame}[fragile]{Inheritance}
  \centering
  \begin{lstlisting}[mathescape=true, escapeinside={(*}{*)}]
    counterClass =
      (*\addedline{$\lambda$r:CounterRep.}*)
        {get = $\lambda$_:Unit. !(r.x),
         inc = $\lambda$_:Unit. r.x := succ(!(r.x))};
  \end{lstlisting}
\end{frame}

\section{Open Recursion}

\end{document}
